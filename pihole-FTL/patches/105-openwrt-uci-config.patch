--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -111,6 +111,8 @@ set(sources
         capabilities.h
         config.c
         config.h
+        config_uci.c
+        config_uci.h
         daemon.c
         daemon.h
         datastructure.c
@@ -216,6 +218,12 @@ else()
     message(STATUS "Building FTL with readline support: NO")
 endif()
 
+find_library(LIBUCI uci)
+if(NOT LIBUCI)
+    message(FATAL_ERROR "libuci not found")
+endif()
+target_link_libraries(pihole-FTL ${LIBUCI})
+
 if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
     set(CMAKE_INSTALL_PREFIX "/usr" CACHE PATH "..." FORCE)
 endif()
--- a/src/api/api.c
+++ b/src/api/api.c
@@ -217,7 +217,7 @@ void getTopDomains(const char *client_me
 	const bool blocked = command(client_message, ">top-ads");
 
 	// Exit before processing any data if requested via config setting
-	get_privacy_level(NULL);
+	get_privacy_level();
 	if(config.privacylevel >= PRIVACY_HIDE_DOMAINS) {
 		// Always send the total number of domains, but pretend it's 0
 		if(!istelnet[*sock])
@@ -266,9 +266,10 @@ void getTopDomains(const char *client_me
 
 
 	// Get filter
-	const char* filter = read_setupVarsconf("API_QUERY_LOG_SHOW");
+	char* filter = NULL;
+	int ret = uci_get_value("pihole", "api_query_log_show", &filter);
 	bool showpermitted = true, showblocked = true;
-	if(filter != NULL)
+	if(filter != NULL && ret == UCI_OK)
 	{
 		if((strcmp(filter, "permittedonly")) == 0)
 			showblocked = false;
@@ -279,6 +280,8 @@ void getTopDomains(const char *client_me
 			showpermitted = false;
 			showblocked = false;
 		}
+
+		FREE(filter);
 	}
 	clearSetupVarsArray();
 
@@ -286,8 +289,8 @@ void getTopDomains(const char *client_me
 	char * excludedomains = NULL;
 	if(!audit)
 	{
-		excludedomains = read_setupVarsconf("API_EXCLUDE_DOMAINS");
-		if(excludedomains != NULL)
+		ret = uci_get_value("pihole", "api_exclude_domains", &excludedomains);
+		if(excludedomains != NULL && ret == UCI_OK)
 		{
 			getSetupVarsArray(excludedomains);
 		}
@@ -359,8 +362,10 @@ void getTopDomains(const char *client_me
 			break;
 	}
 
-	if(excludedomains != NULL)
+	if(excludedomains != NULL) {
 		clearSetupVarsArray();
+		FREE(excludedomains);
+	}
 }
 
 void getTopClients(const char *client_message, const int *sock)
@@ -368,7 +373,7 @@ void getTopClients(const char *client_me
 	int temparray[counters->clients][2], count=10, num;
 
 	// Exit before processing any data if requested via config setting
-	get_privacy_level(NULL);
+	get_privacy_level();
 	if(config.privacylevel >= PRIVACY_HIDE_DOMAINS_CLIENTS) {
 		// Always send the total number of clients, but pretend it's 0
 		if(!istelnet[*sock])
@@ -426,8 +431,9 @@ void getTopClients(const char *client_me
 		qsort(temparray, counters->clients, sizeof(int[2]), cmpdesc);
 
 	// Get clients which the user doesn't want to see
-	const char* excludeclients = read_setupVarsconf("API_EXCLUDE_CLIENTS");
-	if(excludeclients != NULL)
+	char* excludeclients = NULL;
+	int ret = uci_get_value("pihole", "api_exclude_clients", &excludeclients);
+	if(excludeclients != NULL && ret == UCI_OK)
 	{
 		getSetupVarsArray(excludeclients);
 	}
@@ -490,8 +496,10 @@ void getTopClients(const char *client_me
 			break;
 	}
 
-	if(excludeclients != NULL)
+	if(excludeclients != NULL) {
 		clearSetupVarsArray();
+		FREE(excludeclients);
+	}
 }
 
 
@@ -679,7 +687,7 @@ void getQueryTypes(const int *sock)
 void getAllQueries(const char *client_message, const int *sock)
 {
 	// Exit before processing any data if requested via config setting
-	get_privacy_level(NULL);
+	get_privacy_level();
 	if(config.privacylevel >= PRIVACY_MAXIMUM)
 		return;
 
@@ -883,8 +891,9 @@ void getAllQueries(const char *client_me
 	}
 
 	// Get potentially existing filtering flags
-	char * filter = read_setupVarsconf("API_QUERY_LOG_SHOW");
-	if(filter != NULL)
+	char * filter = NULL;
+	int ret = uci_get_value("pihole", "api_query_log_show", &filter);
+	if(filter != NULL && ret == UCI_OK)
 	{
 		if((strcmp(filter, "permittedonly")) == 0)
 			showblocked = false;
@@ -895,6 +904,8 @@ void getAllQueries(const char *client_me
 			showpermitted = false;
 			showblocked = false;
 		}
+
+		FREE(filter);
 	}
 	clearSetupVarsArray();
 
@@ -1211,7 +1222,7 @@ void getClientsOverTime(const int *sock)
 	int sendit = -1, until = OVERTIME_SLOTS;
 
 	// Exit before processing any data if requested via config setting
-	get_privacy_level(NULL);
+	get_privacy_level();
 	if(config.privacylevel >= PRIVACY_HIDE_DOMAINS_CLIENTS)
 		return;
 
@@ -1239,14 +1250,15 @@ void getClientsOverTime(const int *sock)
 	}
 
 	// Get clients which the user doesn't want to see
-	char * excludeclients = read_setupVarsconf("API_EXCLUDE_CLIENTS");
+	char * excludeclients = NULL;
+	int ret = uci_get_value("pihole", "api_exclude_clients", &excludeclients);
 	// Array of clients to be skipped in the output
 	// if skipclient[i] == true then this client should be hidden from
 	// returned data. We initialize it with false
 	bool skipclient[counters->clients];
 	memset(skipclient, false, counters->clients*sizeof(bool));
 
-	if(excludeclients != NULL)
+	if(excludeclients != NULL && ret == UCI_OK)
 	{
 		getSetupVarsArray(excludeclients);
 
@@ -1302,26 +1314,29 @@ void getClientsOverTime(const int *sock)
 			pack_int32(*sock, -1);
 	}
 
-	if(excludeclients != NULL)
+	if(excludeclients != NULL) {
 		clearSetupVarsArray();
+		FREE(excludeclients);
+	}
 }
 
 void getClientNames(const int *sock)
 {
 	// Exit before processing any data if requested via config setting
-	get_privacy_level(NULL);
+	get_privacy_level();
 	if(config.privacylevel >= PRIVACY_HIDE_DOMAINS_CLIENTS)
 		return;
 
 	// Get clients which the user doesn't want to see
-	char * excludeclients = read_setupVarsconf("API_EXCLUDE_CLIENTS");
+	char * excludeclients = NULL;
+	int ret = uci_get_value("pihole", "api_exclude_clients", &excludeclients);
 	// Array of clients to be skipped in the output
 	// if skipclient[i] == true then this client should be hidden from
 	// returned data. We initialize it with false
 	bool skipclient[counters->clients];
 	memset(skipclient, false, counters->clients*sizeof(bool));
 
-	if(excludeclients != NULL)
+	if(excludeclients != NULL && ret == UCI_OK)
 	{
 		getSetupVarsArray(excludeclients);
 
@@ -1367,14 +1382,16 @@ void getClientNames(const int *sock)
 		}
 	}
 
-	if(excludeclients != NULL)
+	if(excludeclients != NULL) {
 		clearSetupVarsArray();
+		FREE(excludeclients);
+	}
 }
 
 void getUnknownQueries(const int *sock)
 {
 	// Exit before processing any data if requested via config setting
-	get_privacy_level(NULL);
+	get_privacy_level();
 	if(config.privacylevel >= PRIVACY_HIDE_DOMAINS)
 		return;
 
--- a/src/config.c
+++ b/src/config.c
@@ -19,14 +19,11 @@
 
 // INT_MAX
 #include <limits.h>
+// uci for getLogFilePath
+#include "config_uci.h"
 
 ConfigStruct config;
 FTLFileNamesStruct FTLfiles = {
-	// Default path for config file (regular installations)
-	"/etc/pihole/pihole-FTL.conf",
-	// Alternative path for config file (snap installations)
-	"/var/snap/pihole/common/etc/pihole/pihole-FTL.conf",
-	NULL,
 	NULL,
 	NULL,
 	NULL,
@@ -37,53 +34,21 @@ FTLFileNamesStruct FTLfiles = {
 	NULL
 };
 
-pthread_mutex_t lock;
-
-// Private global variables
-static char *conflinebuffer = NULL;
-static size_t size = 0;
-
 // Private prototypes
-static char *parse_FTLconf(FILE *fp, const char * key);
-static void getpath(FILE* fp, const char *option, const char *defaultloc, char **pointer);
-static bool read_bool(const char *option, const bool fallback);
-
-void init_config_mutex(void)
-{
-	// Initialize the lock attributes
-	pthread_mutexattr_t lock_attr = {};
-	pthread_mutexattr_init(&lock_attr);
-
-	// Initialize the lock
-	pthread_mutex_init(&lock, &lock_attr);
-
-	// Destroy the lock attributes since we're done with it
-	pthread_mutexattr_destroy(&lock_attr);
-}
+static void getpath(const char *option, const char *defaultloc, char **pointer);
 
 void getLogFilePath(void)
 {
-	FILE *fp;
 	char * buffer;
-
-	// Try to open default config file. Use fallback if not found
-	if( ((fp = fopen(FTLfiles.conf, "r")) == NULL) &&
-	    ((fp = fopen(FTLfiles.snapConf, "r")) == NULL) &&
-	    ((fp = fopen("pihole-FTL.conf", "r")) == NULL))
-	{
-		printf("Notice: Found no readable FTL config file\n");
-	}
-
-	// Read LOGFILE value if available
-	// defaults to: "/var/log/pihole-FTL.log"
-	buffer = parse_FTLconf(fp, "LOGFILE");
+	int ret = uci_get_value("pihole", "logfile", &buffer);
 
 	errno = 0;
 	// Use sscanf() to obtain filename from config file parameter only if buffer != NULL
-	if(buffer == NULL || sscanf(buffer, "%127ms", &FTLfiles.log) != 1)
+ 	if(ret != UCI_OK || buffer == NULL || sscanf(buffer, "%127ms", &FTLfiles.log) != 1)
 	{
 		// Use standard path if no custom path was obtained from the config file
 		FTLfiles.log = strdup("/var/log/pihole-FTL.log");
+		syslog(LOG_WARNING, "pihole-FTL: User defined log file is invalid, fallback to default.");
 	}
 
 	// Test if memory allocation was successful
@@ -100,56 +65,51 @@ void getLogFilePath(void)
 	}
 	else
 		logg("Using log file %s", FTLfiles.log);
+
+	FREE(buffer);
 }
 
 void read_FTLconf(void)
 {
-	FILE *fp;
-	char * buffer;
-
-	// Try to open default config file. Use fallback if not found
-	if( ((fp = fopen(FTLfiles.conf, "r")) == NULL) &&
-	    ((fp = fopen(FTLfiles.snapConf, "r")) == NULL) &&
-	    ((fp = fopen("pihole-FTL.conf", "r")) == NULL))
-	{
-		logg("Notice: Found no readable FTL config file");
-		logg("        Using default settings");
-	}
+	char *buffer = NULL;
+	int ret;
 
 	// Parse lines in the config file
-	logg("Starting config file parsing (%s)", FTLfiles.conf);
+	logg("Reading uci config (/etc/config/pihole) started");
 
 	// SOCKET_LISTENING
 	// defaults to: listen only local
 	config.socket_listenlocal = true;
-	buffer = parse_FTLconf(fp, "SOCKET_LISTENING");
+	ret = uci_get_value("pihole", "socket_listening", &buffer);
 
-	if(buffer != NULL && strcasecmp(buffer, "all") == 0)
+	if(ret == UCI_OK && buffer != NULL && strcasecmp(buffer, "all") == 0) {
 		config.socket_listenlocal = false;
-
-	if(config.socket_listenlocal)
-		logg("   SOCKET_LISTENING: only local");
-	else
 		logg("   SOCKET_LISTENING: all destinations");
+	} else {
+		logg("   SOCKET_LISTENING: only local");
+	}
+	FREE(buffer);
 
 	// AAAA_QUERY_ANALYSIS
 	// defaults to: Yes
-	buffer = parse_FTLconf(fp, "AAAA_QUERY_ANALYSIS");
-	config.analyze_AAAA = read_bool(buffer, true);
+	config.analyze_AAAA = true;
+	ret = uci_get_value("pihole", "aaaa_query_analysis", &buffer);
 
-	if(config.analyze_AAAA)
-		logg("   AAAA_QUERY_ANALYSIS: Show AAAA queries");
-	else
+	if(ret == UCI_OK && buffer != NULL && strcmp(buffer, "0") == 0) {
+		config.analyze_AAAA = false;
 		logg("   AAAA_QUERY_ANALYSIS: Hide AAAA queries");
+	} else {
+ 		logg("   AAAA_QUERY_ANALYSIS: Show AAAA queries");
+	}
+	FREE(buffer);
 
 	// MAXDBDAYS
-	// defaults to: 365 days
-	config.maxDBdays = 365;
-	buffer = parse_FTLconf(fp, "MAXDBDAYS");
-
+	// defaults to: 1 days
 	int value = 0;
 	const int maxdbdays_max = INT_MAX / 24 / 60 / 60;
-	if(buffer != NULL && sscanf(buffer, "%i", &value))
+	config.maxDBdays = 1;
+	ret = uci_get_value("pihole", "maxdbdays", &buffer);
+	if(ret == UCI_OK && buffer != NULL && sscanf(buffer, "%i", &value))
 	{
 		// Prevent possible overflow
 		if(value > maxdbdays_max)
@@ -159,6 +119,7 @@ void read_FTLconf(void)
 		if(value == -1 || value >= 0)
 			config.maxDBdays = value;
 	}
+	FREE(buffer);
 
 	if(config.maxDBdays == 0)
 		logg("   MAXDBDAYS: --- (DB disabled)");
@@ -169,92 +130,76 @@ void read_FTLconf(void)
 
 	// RESOLVE_IPV6
 	// defaults to: Yes
-	buffer = parse_FTLconf(fp, "RESOLVE_IPV6");
-	config.resolveIPv6 = read_bool(buffer, true);
+	config.resolveIPv6 = true;
+	ret = uci_get_value("pihole", "resolve_ipv6", &buffer);
 
-	if(config.resolveIPv6)
-		logg("   RESOLVE_IPV6: Resolve IPv6 addresses");
-	else
+	if(ret == UCI_OK && buffer != NULL && strcmp(buffer, "0") == 0) {
+		config.resolveIPv6 = false;
 		logg("   RESOLVE_IPV6: Don\'t resolve IPv6 addresses");
+	} else {
+		logg("   RESOLVE_IPV6: Resolve IPv6 addresses");
+	}
+	FREE(buffer);
 
 	// RESOLVE_IPV4
 	// defaults to: Yes
-	buffer = parse_FTLconf(fp, "RESOLVE_IPV4");
-	config.resolveIPv4 = read_bool(buffer, true);
+	config.resolveIPv4 = true;
+	ret = uci_get_value("pihole", "resolve_ipv4", &buffer);
 
-	if(config.resolveIPv4)
-		logg("   RESOLVE_IPV4: Resolve IPv4 addresses");
-	else
+	if(ret == UCI_OK && buffer != NULL && strcmp(buffer, "0") == 0) {
+		config.resolveIPv4 = false;
 		logg("   RESOLVE_IPV4: Don\'t resolve IPv4 addresses");
+	} else {
+		logg("   RESOLVE_IPV4: Resolve IPv4 addresses");
+	}
+	FREE(buffer);
 
 	// DBINTERVAL
 	// How often do we store queries in FTL's database [minutes]?
 	// this value can be a floating point number, e.g. "DBINTERVAL=0.5"
 	// defaults to: once per minute
 	config.DBinterval = 60;
-	buffer = parse_FTLconf(fp, "DBINTERVAL");
-
 	float fvalue = 0;
-	if(buffer != NULL && sscanf(buffer, "%f", &fvalue))
+	ret = uci_get_value("pihole", "dbinterval", &buffer);
+	if(ret == UCI_OK && buffer != NULL && sscanf(buffer, "%f", &fvalue))
 		// check if the read value is
 		// - larger than 0.1min (6sec), and
 		// - smaller than 1440.0min (once a day)
 		if(fvalue >= 0.1f && fvalue <= 1440.0f)
 			config.DBinterval = (int)(fvalue * 60);
 
+	FREE(buffer);
 	if(config.DBinterval == 60)
 		logg("   DBINTERVAL: saving to DB file every minute");
 	else
 		logg("   DBINTERVAL: saving to DB file every %lli seconds", (long long)config.DBinterval);
 
-	// DBFILE
-	// defaults to: "/etc/pihole/pihole-FTL.db"
-	buffer = parse_FTLconf(fp, "DBFILE");
-
-	// Use sscanf() to obtain filename from config file parameter only if buffer != NULL
-	if(!(buffer != NULL && sscanf(buffer, "%127ms", &FTLfiles.FTL_db)))
-	{
-		// Use standard path if no custom path was obtained from the config file
-		FTLfiles.FTL_db = strdup("/etc/pihole/pihole-FTL.db");
-	}
-
-	if(FTLfiles.FTL_db != NULL && strlen(FTLfiles.FTL_db) > 0)
-		logg("   DBFILE: Using %s", FTLfiles.FTL_db);
-	else
-	{
-		// Use standard path if path was set to zero but override
-		// MAXDBDAYS=0 to ensure no queries are stored in the database
-		FTLfiles.FTL_db = strdup("/etc/pihole/pihole-FTL.db");
-		config.maxDBdays = 0;
-		logg("   DBFILE: Using %s (not storing queries)", FTLfiles.FTL_db);
-	}
-
 	// FTLPORT
 	// On which port should FTL be listening?
 	// defaults to: 4711
 	config.port = 4711;
-	buffer = parse_FTLconf(fp, "FTLPORT");
-
 	value = 0;
-	if(buffer != NULL && sscanf(buffer, "%i", &value))
+	ret = uci_get_value("pihole", "ftlport", &buffer);
+	if(ret == UCI_OK && buffer != NULL && sscanf(buffer, "%i", &value))
 		if(value > 0 && value <= 65535)
 			config.port = value;
 
+	FREE(buffer);
 	// MAXLOGAGE
 	// Up to how many hours in the past should queries be imported from the database?
 	// defaults to: 24.0 via MAXLOGAGE defined in FTL.h
+	const char *hint = "";
 	config.maxlogage = MAXLOGAGE*3600;
-	buffer = parse_FTLconf(fp, "MAXLOGAGE");
-
+	ret = uci_get_value("pihole", "maxlogage", &buffer);
 	fvalue = 0;
-	const char *hint = "";
-	if(buffer != NULL && sscanf(buffer, "%f", &fvalue))
+	if(ret == UCI_OK && buffer != NULL && sscanf(buffer, "%f", &fvalue))
 	{
 		if(fvalue >= 0.0f && fvalue <= 1.0f*MAXLOGAGE)
 			config.maxlogage = (int)(fvalue * 3600);
 		else if(fvalue > 1.0f*MAXLOGAGE)
 			hint = " (value has been clipped to " str(MAXLOGAGE) " hours)";
 	}
+	FREE(buffer);
 	logg("   MAXLOGAGE: Importing up to %.1f hours of log data%s",
 	     (float)config.maxlogage/3600.0f, hint);
 
@@ -268,26 +213,25 @@ void read_FTLconf(void)
 	//                       added to the database, no entries visible in the query log and no Top Item Lists
 	// PRIVACY_NOSTATS (4) = Disable any analysis on queries. No counters are available in this mode.
 	// defaults to: PRIVACY_SHOW_ALL
-	config.privacylevel = PRIVACY_SHOW_ALL;
-	get_privacy_level(fp);
+	get_privacy_level();
 	logg("   PRIVACYLEVEL: Set to %i", config.privacylevel);
 
 	// IGNORE_LOCALHOST
 	// defaults to: false
-	buffer = parse_FTLconf(fp, "IGNORE_LOCALHOST");
-	config.ignore_localhost = read_bool(buffer, false);
+	config.ignore_localhost = false;
+	ret = uci_get_value("pihole", "ignore_localhost", &buffer);
 
-	if(buffer != NULL && strcasecmp(buffer, "yes") == 0)
+	if(ret == UCI_OK && buffer != NULL && strcmp(buffer, "1") == 0) {
 		config.ignore_localhost = true;
-
-	if(config.ignore_localhost)
 		logg("   IGNORE_LOCALHOST: Hide queries from localhost");
-	else
+	} else {
 		logg("   IGNORE_LOCALHOST: Show queries from localhost");
+	}
+	FREE(buffer);
 
 	// BLOCKINGMODE
 	// defaults to: MODE_IP
-	get_blocking_mode(fp);
+	get_blocking_mode();
 	switch(config.blockingmode)
 	{
 		case MODE_NX:
@@ -309,104 +253,118 @@ void read_FTLconf(void)
 
 	// ANALYZE_ONLY_A_AND_AAAA
 	// defaults to: false
-	buffer = parse_FTLconf(fp, "ANALYZE_ONLY_A_AND_AAAA");
-	config.analyze_only_A_AAAA = read_bool(buffer, false);
+	config.analyze_only_A_AAAA = false;
+	ret = uci_get_value("pihole", "analyze_only_a_aaaa", &buffer);
 
-	if(buffer != NULL && strcasecmp(buffer, "true") == 0)
+	if(ret == UCI_OK && buffer != NULL && strcmp(buffer, "1") == 0) {
 		config.analyze_only_A_AAAA = true;
-
-	if(config.analyze_only_A_AAAA)
 		logg("   ANALYZE_ONLY_A_AND_AAAA: Enabled. Analyzing only A and AAAA queries");
-	else
+	} else {
 		logg("   ANALYZE_ONLY_A_AND_AAAA: Disabled. Analyzing all queries");
+	}
+	FREE(buffer);
 
 	// DBIMPORT
 	// defaults to: Yes
-	buffer = parse_FTLconf(fp, "DBIMPORT");
-	config.DBimport = read_bool(buffer, true);
+	config.DBimport = true;
+	ret = uci_get_value("pihole", "dbimport", &buffer);
 
-	if(config.DBimport)
-	{
+	if(ret == UCI_OK && buffer != NULL && strcmp(buffer, "0") == 0)
+		config.DBimport = false;
+
+	FREE(buffer);
+	if(config.DBimport) {
 		logg("   DBIMPORT: Importing history from database");
 		if(config.maxDBdays == 0)
 			logg("      Hint: Exporting queries has been disabled (MAXDBDAYS=0)!");
-	}
-	else
+	} else {
 		logg("   DBIMPORT: Not importing history from database");
+	}
 
 	// PIDFILE
-	getpath(fp, "PIDFILE", "/run/pihole-FTL.pid", &FTLfiles.pid);
+	getpath("pidfile", "/var/run/pihole/pihole-FTL.pid", &FTLfiles.pid);
 
 	// PORTFILE
-	getpath(fp, "PORTFILE", "/run/pihole-FTL.port", &FTLfiles.port);
+	getpath("portfile", "/var/run/pihole/pihole-FTL.port", &FTLfiles.port);
 	saveport(config.port);
 
 	// SOCKETFILE
-	getpath(fp, "SOCKETFILE", "/run/pihole/FTL.sock", &FTLfiles.socketfile);
-
-	// SETUPVARSFILE
-	getpath(fp, "SETUPVARSFILE", "/etc/pihole/setupVars.conf", &FTLfiles.setupVars);
+	getpath("socketfile", "/var/run/pihole/FTL.sock", &FTLfiles.socketfile);
 
 	// MACVENDORDB
-	getpath(fp, "MACVENDORDB", "/etc/pihole/macvendor.db", &FTLfiles.macvendor_db);
+	getpath("macvendordb", "/etc/pihole/macvendor.db", &FTLfiles.macvendor_db);
 
 	// GRAVITYDB
-	getpath(fp, "GRAVITYDB", "/etc/pihole/gravity.db", &FTLfiles.gravity_db);
+	getpath("gravitydb", "/etc/pihole/gravity.db", &FTLfiles.gravity_db);
+
+	// DBFILE
+	getpath("dbfile", "/etc/pihole/pihole-FTL.db", &FTLfiles.FTL_db);
 
 	// PARSE_ARP_CACHE
 	// defaults to: true
-	buffer = parse_FTLconf(fp, "PARSE_ARP_CACHE");
-	config.parse_arp_cache = read_bool(buffer, true);
+	config.parse_arp_cache = true;
+	ret = uci_get_value("pihole", "parse_arp_cache", &buffer);
 
-	if(config.parse_arp_cache)
-		logg("   PARSE_ARP_CACHE: Active");
-	else
+	if(ret == UCI_OK && buffer != NULL && strcmp(buffer, "0") == 0) {
+		config.parse_arp_cache = false;
 		logg("   PARSE_ARP_CACHE: Inactive");
+	} else {
+		logg("   PARSE_ARP_CACHE: Active");
+	}
+	FREE(buffer);
 
 	// CNAME_DEEP_INSPECT
 	// defaults to: true
-	buffer = parse_FTLconf(fp, "CNAME_DEEP_INSPECT");
-	config.cname_inspection = read_bool(buffer, true);
+	config.cname_inspection = true;
+	ret = uci_get_value("pihole", "cname_deep_inspect", &buffer);
 
-	if(config.cname_inspection)
-		logg("   CNAME_DEEP_INSPECT: Active");
-	else
+	if(ret == UCI_OK && buffer != NULL && strcmp(buffer, "0") == 0) {
+		config.cname_inspection = false;
 		logg("   CNAME_DEEP_INSPECT: Inactive");
+	} else {
+		logg("   CNAME_DEEP_INSPECT: Active");
+	}
+	FREE(buffer);
 
 	// DELAY_STARTUP
 	// defaults to: zero (seconds)
-	buffer = parse_FTLconf(fp, "DELAY_STARTUP");
-
 	config.delay_startup = 0;
-	if(buffer != NULL && sscanf(buffer, "%u", &config.delay_startup) &&
-	   (config.delay_startup > 0 && config.delay_startup <= 300))
+	ret = uci_get_value("pihole", "delay_startup", &buffer);
+
+	if(ret == UCI_OK && buffer != NULL && sscanf(buffer, "%u", &config.delay_startup) &&
+	   (config.delay_startup > 0 && config.delay_startup <= 300)) {
 		logg("   DELAY_STARTUP: Requested to wait %u seconds during startup.", config.delay_startup);
-	else
+	} else {
 		logg("   DELAY_STARTUP: No delay requested.");
+	}
+	FREE(buffer);
 
 	// BLOCK_ESNI
 	// defaults to: true
-	buffer = parse_FTLconf(fp, "BLOCK_ESNI");
-	config.block_esni = read_bool(buffer, true);
+	config.block_esni = true;
+	ret = uci_get_value("pihole", "block_esni", &buffer);
 
-	if(config.block_esni)
-		logg("   BLOCK_ESNI: Enabled, blocking _esni.{blocked domain}");
-	else
+	if(ret == UCI_OK && buffer != NULL && strcmp(buffer, "0") == 0) {
+		config.block_esni = false;
 		logg("   BLOCK_ESNI: Disabled");
+	} else {
+		logg("   BLOCK_ESNI: Enabled, blocking _esni.{blocked domain}");
+	}
+	FREE(buffer);
 
 	// MAXNETAGE
 	// IP addresses (and associated host names) older than the specified number
 	// of days are removed to avoid dead entries in the network overview table
 	// defaults to: the same value as MAXDBDAYS
 	config.network_expire = config.maxDBdays;
-	buffer = parse_FTLconf(fp, "MAXNETAGE");
-
 	int ivalue = 0;
-	if(buffer != NULL &&
+	ret = uci_get_value("pihole", "maxnetage", &buffer);
+	if(ret == UCI_OK && buffer != NULL &&
 	    sscanf(buffer, "%i", &ivalue) &&
 	    ivalue > 0 && ivalue <= 8760) // 8760 days = 24 years
 			config.network_expire = ivalue;
 
+	FREE(buffer);
 	if(config.network_expire > 0u)
 		logg("   MAXNETAGE: Removing IP addresses and host names from network table after %u days",
 		     config.network_expire);
@@ -421,41 +379,47 @@ void read_FTLconf(void)
 	// we use the host name associated to the other address as this is the same
 	// device. This behavior can be disabled using NAMES_FROM_NETDB=false
 	// defaults to: true
-	buffer = parse_FTLconf(fp, "NAMES_FROM_NETDB");
-	config.names_from_netdb = read_bool(buffer, true);
+	config.names_from_netdb = true;
+	ret = uci_get_value("pihole", "names_from_netdb", &buffer);
 
-	if(config.names_from_netdb)
-		logg("   NAMES_FROM_NETDB: Enabled, trying to get names from network database");
-	else
+	if(ret == UCI_OK && buffer != NULL && strcmp(buffer, "0") == 0) {
+		config.names_from_netdb = false;
 		logg("   NAMES_FROM_NETDB: Disabled");
+	} else {
+		logg("   NAMES_FROM_NETDB: Enabled, trying to get names from network database");
+	}
+	FREE(buffer);
 
 	// EDNS0_ECS
 	// Should we overwrite the query source when client information is
 	// provided through EDNS0 client subnet (ECS) information?
 	// defaults to: true
-	buffer = parse_FTLconf(fp, "EDNS0_ECS");
-	config.edns0_ecs = read_bool(buffer, true);
+	config.edns0_ecs = true;
+	ret = uci_get_value("pihole", "edns0_ecs", &buffer);
 
-	if(config.edns0_ecs)
-		logg("   EDNS0_ECS: Overwrite client from ECS information");
-	else
+	if(ret == UCI_OK && buffer != NULL && strcmp(buffer, "0") == 0) {
+		config.edns0_ecs = false;
 		logg("   EDNS0_ECS: Don't use ECS information");
+	} else {
+		logg("   EDNS0_ECS: Overwrite client from ECS information");
+	}
+	FREE(buffer);
 
 	// REFRESH_HOSTNAMES
 	// defaults to: IPV4
-	buffer = parse_FTLconf(fp, "REFRESH_HOSTNAMES");
+	ret = uci_get_value("pihole", "refresh_hostnames", &buffer);
 
-	if(buffer != NULL && strcasecmp(buffer, "ALL") == 0)
+	if(ret == UCI_OK && buffer != NULL && strcasecmp(buffer, "all") == 0)
 	{
 		config.refresh_hostnames = REFRESH_ALL;
 		logg("   REFRESH_HOSTNAMES: Periodically refreshing all names");
 	}
-	else if(buffer != NULL && strcasecmp(buffer, "NONE") == 0)
+	else if(buffer != NULL && strcasecmp(buffer, "none") == 0)
 	{
 		config.refresh_hostnames = REFRESH_NONE;
 		logg("   REFRESH_HOSTNAMES: Not periodically refreshing names");
 	}
-	else if(buffer != NULL && strcasecmp(buffer, "UNKNOWN") == 0)
+	else if(buffer != NULL && strcasecmp(buffer, "unknown") == 0)
 	{
 		config.refresh_hostnames = REFRESH_UNKNOWN;
 		logg("   REFRESH_HOSTNAMES: Only refreshing recently active clients with unknown hostnames");
@@ -465,20 +429,22 @@ void read_FTLconf(void)
 		config.refresh_hostnames = REFRESH_IPV4_ONLY;
 		logg("   REFRESH_HOSTNAMES: Periodically refreshing IPv4 names");
 	}
+	FREE(buffer);
 
 	// RATE_LIMIT
 	// defaults to: 1000 queries / 60 seconds
 	config.rate_limit.count = 1000;
 	config.rate_limit.interval = 60;
-	buffer = parse_FTLconf(fp, "RATE_LIMIT");
+	ret = uci_get_value("pihole", "rate_limit", &buffer);
 
 	unsigned int count = 0, interval = 0;
-	if(buffer != NULL && sscanf(buffer, "%u/%u", &count, &interval) == 2)
+	if(ret == UCI_OK && buffer != NULL && sscanf(buffer, "%u/%u", &count, &interval) == 2)
 	{
 		config.rate_limit.count = count;
 		config.rate_limit.interval = interval;
 	}
 
+	FREE(buffer);
 	if(config.rate_limit.count > 0)
 		logg("   RATE_LIMIT: Rate-limiting client making more than %u queries in %u second%s",
 		     config.rate_limit.count, config.rate_limit.interval, config.rate_limit.interval == 1 ? "" : "s");
@@ -491,10 +457,11 @@ void read_FTLconf(void)
 	// defaults to: not set
 	config.reply_addr.own_host.overwrite_v4 = false;
 	config.reply_addr.own_host.v4.s_addr = 0;
-	buffer = parse_FTLconf(fp, "LOCAL_IPV4");
-	if(buffer != NULL && inet_pton(AF_INET, buffer, &config.reply_addr.own_host.v4))
+	ret = uci_get_value("pihole", "local_ipv4", &buffer);
+	if(ret == UCI_OK && buffer != NULL && inet_pton(AF_INET, buffer, &config.reply_addr.own_host.v4))
 		config.reply_addr.own_host.overwrite_v4 = true;
 
+	FREE(buffer);
 	if(config.reply_addr.own_host.overwrite_v4)
 	{
 		char addr[INET_ADDRSTRLEN] = { 0 };
@@ -510,10 +477,11 @@ void read_FTLconf(void)
 	// defaults to: not set
 	config.reply_addr.own_host.overwrite_v6 = false;
 	memset(&config.reply_addr.own_host.v6, 0, sizeof(config.reply_addr.own_host.v6));
-	buffer = parse_FTLconf(fp, "LOCAL_IPV6");
-	if(buffer != NULL && inet_pton(AF_INET6, buffer, &config.reply_addr.own_host.v6))
+	ret = uci_get_value("pihole", "local_ipv6", &buffer);
+	if(ret == UCI_OK && buffer != NULL && inet_pton(AF_INET6, buffer, &config.reply_addr.own_host.v6))
 		config.reply_addr.own_host.overwrite_v6 = true;
 
+	FREE(buffer);
 	if(config.reply_addr.own_host.overwrite_v6)
 	{
 		char addr[INET6_ADDRSTRLEN] = { 0 };
@@ -528,10 +496,11 @@ void read_FTLconf(void)
 	// defaults to: REPLY_ADDR4 setting
 	config.reply_addr.ip_blocking.overwrite_v4 = false;
 	config.reply_addr.ip_blocking.v4.s_addr = 0;
-	buffer = parse_FTLconf(fp, "BLOCK_IPV4");
-	if(buffer != NULL && inet_pton(AF_INET, buffer, &config.reply_addr.ip_blocking.v4))
+	ret = uci_get_value("pihole", "block_ipv4", &buffer);
+	if(ret == UCI_OK && buffer != NULL && inet_pton(AF_INET, buffer, &config.reply_addr.ip_blocking.v4))
 		config.reply_addr.ip_blocking.overwrite_v4 = true;
 
+	FREE(buffer);
 	if(config.reply_addr.ip_blocking.overwrite_v4)
 	{
 		char addr[INET_ADDRSTRLEN] = { 0 };
@@ -546,10 +515,11 @@ void read_FTLconf(void)
 	// defaults to: REPLY_ADDR6 setting
 	config.reply_addr.ip_blocking.overwrite_v6 = false;
 	memset(&config.reply_addr.ip_blocking.v6, 0, sizeof(config.reply_addr.own_host.v6));
-	buffer = parse_FTLconf(fp, "BLOCK_IPV6");
-	if(buffer != NULL && inet_pton(AF_INET6, buffer, &config.reply_addr.ip_blocking.v6))
+	ret = uci_get_value("pihole", "block_ipv6", &buffer);
+	if(ret == UCI_OK && buffer != NULL && inet_pton(AF_INET6, buffer, &config.reply_addr.ip_blocking.v6))
 		config.reply_addr.ip_blocking.overwrite_v6 = true;
 
+	FREE(buffer);
 	if(config.reply_addr.ip_blocking.overwrite_v6)
 	{
 		char addr[INET6_ADDRSTRLEN] = { 0 };
@@ -564,8 +534,8 @@ void read_FTLconf(void)
 	// IPv4 interface address a query arrived on A hostname and IP blocked queries
 	// defaults to: not set
 	struct in_addr reply_addr4;
-	buffer = parse_FTLconf(fp, "REPLY_ADDR4");
-	if(buffer != NULL && inet_pton(AF_INET, buffer, &reply_addr4))
+	ret = uci_get_value("pihole", "reply_addr4", &buffer);
+	if(ret == UCI_OK && buffer != NULL && inet_pton(AF_INET, buffer, &reply_addr4))
 	{
 		if(config.reply_addr.own_host.overwrite_v4 || config.reply_addr.ip_blocking.overwrite_v4)
 		{
@@ -583,14 +553,15 @@ void read_FTLconf(void)
 			logg("   REPLY_ADDR4: Using IPv4 address %s instead of automatically determined IP address", addr);
 		}
 	}
+	FREE(buffer);
 
 	// REPLY_ADDR6 (deprecated setting)
 	// Use a specific IP address instead of automatically detecting the
 	// IPv4 interface address a query arrived on A hostname and IP blocked queries
 	// defaults to: not set
 	struct in6_addr reply_addr6;
-	buffer = parse_FTLconf(fp, "REPLY_ADDR6");
-	if(buffer != NULL && inet_pton(AF_INET, buffer, &reply_addr6))
+	ret = uci_get_value("pihole", "reply_addr6", &buffer);
+	if(ret == UCI_OK && buffer != NULL && inet_pton(AF_INET, buffer, &reply_addr6))
 	{
 		if(config.reply_addr.own_host.overwrite_v6 || config.reply_addr.ip_blocking.overwrite_v6)
 		{
@@ -608,35 +579,42 @@ void read_FTLconf(void)
 			logg("   REPLY_ADDR6: Using IPv6 address %s instead of automatically determined IP address", addr);
 		}
 	}
+	FREE(buffer);
 
 	// SHOW_DNSSEC
 	// Should FTL analyze and include automatically generated DNSSEC queries in the Query Log?
 	// defaults to: true
-	buffer = parse_FTLconf(fp, "SHOW_DNSSEC");
-	config.show_dnssec = read_bool(buffer, true);
+	config.show_dnssec = true;
+	ret = uci_get_value("pihole", "show_dnssec", &buffer);
 
-	if(config.show_dnssec)
-		logg("   SHOW_DNSSEC: Enabled, showing automatically generated DNSSEC queries");
-	else
+	if(ret == UCI_OK && buffer != NULL && strcmp(buffer, "0") == 0) {
+		config.show_dnssec = false;
 		logg("   SHOW_DNSSEC: Disabled");
+	} else {
+		logg("   SHOW_DNSSEC: Enabled, showing automatically generated DNSSEC queries");
+	}
+	FREE(buffer);
 
 	// MOZILLA_CANARY
 	// Should FTL handle use-application-dns.net specifically and always return NXDOMAIN?
 	// defaults to: true
-	buffer = parse_FTLconf(fp, "MOZILLA_CANARY");
-	config.special_domains.mozilla_canary = read_bool(buffer, true);
+	config.special_domains.mozilla_canary = true;
+	ret = uci_get_value("pihole", "mozilla_canary", &buffer);
 
-	if(config.special_domains.mozilla_canary)
-		logg("   MOZILLA_CANARY: Enabled");
-	else
+	if(ret == UCI_OK && buffer != NULL && strcmp(buffer, "0") == 0) {
+		config.special_domains.mozilla_canary = false;
 		logg("   MOZILLA_CANARY: Disabled");
+	} else {
+		logg("   MOZILLA_CANARY: Enabled");
+	}
+	FREE(buffer);
 
 	// PIHOLE_PTR
 	// Should FTL return "pi.hole" as name for PTR requests to local IP addresses?
 	// defaults to: PI.HOLE
-	buffer = parse_FTLconf(fp, "PIHOLE_PTR");
+	ret = uci_get_value("pihole", "pihole_ptr", &buffer);
 
-	if(buffer != NULL && (strcasecmp(buffer, "none") == 0 ||
+	if(ret == UCI_OK && buffer != NULL && (strcasecmp(buffer, "none") == 0 ||
 	                      strcasecmp(buffer, "false") == 0))
 	{
 		config.pihole_ptr = PTR_NONE;
@@ -657,23 +635,24 @@ void read_FTLconf(void)
 		config.pihole_ptr = PTR_PIHOLE;
 		logg("   PIHOLE_PTR: internal PTR generation enabled (pi.hole)");
 	}
+	FREE(buffer);
 
 	// REPLY_WHEN_BUSY
 	// How should FTL handle queries when the gravity database is not available?
-	// defaults to: BLOCK
-	buffer = parse_FTLconf(fp, "REPLY_WHEN_BUSY");
+	// defaults to: ALLOW
+	ret = uci_get_value("pihole", "reply_when_busy", &buffer);
 
-	if(buffer != NULL && strcasecmp(buffer, "DROP") == 0)
+	if(ret == UCI_OK && buffer != NULL && strcasecmp(buffer, "drop") == 0)
 	{
 		config.reply_when_busy = BUSY_DROP;
 		logg("   REPLY_WHEN_BUSY: Drop queries when the database is busy");
 	}
-	else if(buffer != NULL && strcasecmp(buffer, "REFUSE") == 0)
+	else if(buffer != NULL && strcasecmp(buffer, "refuse") == 0)
 	{
 		config.reply_when_busy = BUSY_REFUSE;
 		logg("   REPLY_WHEN_BUSY: Refuse queries when the database is busy");
 	}
-	else if(buffer != NULL && strcasecmp(buffer, "BLOCK") == 0)
+	else if(buffer != NULL && strcasecmp(buffer, "block") == 0)
 	{
 		config.reply_when_busy = BUSY_BLOCK;
 		logg("   REPLY_WHEN_BUSY: Block queries when the database is busy");
@@ -683,16 +662,17 @@ void read_FTLconf(void)
 		config.reply_when_busy = BUSY_ALLOW;
 		logg("   REPLY_WHEN_BUSY: Permit queries when the database is busy");
 	}
+	FREE(buffer);
 
 	// BLOCK_TTL
 	// defaults to: 2 seconds
 	config.block_ttl = 2;
-	buffer = parse_FTLconf(fp, "BLOCK_TTL");
-
+	ret = uci_get_value("pihole", "block_ttl", &buffer);
 	unsigned int uval = 0;
-	if(buffer != NULL && sscanf(buffer, "%u", &uval))
+	if(ret == UCI_OK && buffer != NULL && sscanf(buffer, "%u", &uval))
 		config.block_ttl = uval;
 
+	FREE(buffer);
 	if(config.block_ttl == 1)
 		logg("   BLOCK_TTL: 1 second");
 	else
@@ -702,85 +682,97 @@ void read_FTLconf(void)
 	// Should FTL handle the iCloud privacy relay domains specifically and
 	// always return NXDOMAIN?
 	// defaults to: true
-	buffer = parse_FTLconf(fp, "BLOCK_ICLOUD_PR");
-	config.special_domains.icloud_private_relay = read_bool(buffer, true);
+	config.special_domains.icloud_private_relay = true;
+	ret = uci_get_value("pihole", "block_icloud_pr", &buffer);
 
-	if(config.special_domains.icloud_private_relay)
-		logg("   BLOCK_ICLOUD_PR: Enabled");
-	else
+	if(ret == UCI_OK && buffer != NULL && strcmp(buffer, "0") == 0) {
+		config.special_domains.icloud_private_relay = false;
 		logg("   BLOCK_ICLOUD_PR: Disabled");
+	} else {
+		logg("   BLOCK_ICLOUD_PR: Enabled");
+	}
 
 	// CHECK_LOAD
 	// Should FTL check the 15 min average of CPU load and complain if the
 	// load is larger than the number of available CPU cores?
 	// defaults to: true
-	buffer = parse_FTLconf(fp, "CHECK_LOAD");
-	config.check.load = read_bool(buffer, true);
+	config.check.load = true;
+	ret = uci_get_value("pihole", "check_load", &buffer);
 
-	if(config.check.load)
-		logg("   CHECK_LOAD: Enabled");
-	else
+	if(ret == UCI_OK && buffer != NULL && strcmp(buffer, "0") == 0) {
+		config.check.load = false;
 		logg("   CHECK_LOAD: Disabled");
+	} else {
+		logg("   CHECK_LOAD: Enabled");
+	}
+	FREE(buffer);
 
 	// CHECK_SHMEM
 	// Limit above which FTL should complain about a shared-memory shortage
 	// defaults to: 90%
+	value = 0;
 	config.check.shmem = 90;
-	buffer = parse_FTLconf(fp, "CHECK_SHMEM");
+	ret = uci_get_value("pihole", "check_shmem", &buffer);
 
-	if(buffer != NULL &&
+	if(ret == UCI_OK && buffer != NULL &&
 	    sscanf(buffer, "%i", &ivalue) &&
 	    ivalue >= 0 && ivalue <= 100)
 			config.check.shmem = ivalue;
 
+	FREE(buffer);
 	logg("   CHECK_SHMEM: Warning if shared-memory usage exceeds %d%%", config.check.shmem);
 
 	// CHECK_DISK
 	// Limit above which FTL should complain about disk shortage for checked files
 	// defaults to: 90%
+	value = 0;
 	config.check.disk = 90;
-	buffer = parse_FTLconf(fp, "CHECK_DISK");
+	ret = uci_get_value("pihole", "check_disk", &buffer);
 
-	if(buffer != NULL &&
+	if(ret == UCI_OK && buffer != NULL &&
 	    sscanf(buffer, "%i", &ivalue) &&
 	    ivalue >= 0 && ivalue <= 100)
 			config.check.disk = ivalue;
 
+	FREE(buffer);
 	logg("   CHECK_DISK: Warning if certain disk usage exceeds %d%%", config.check.disk);
-
-	// Read DEBUG_... setting from pihole-FTL.conf
-	read_debuging_settings(fp);
-
+ 
 	// SHM_LOG
 	// defaults to: false
 	config.shm_log = false;
-	buffer = parse_FTLconf(fp, "SHM_LOG");
+	ret = uci_get_value("pihole", "shm_log", &buffer);
 
-	if(buffer != NULL && strcasecmp(buffer, "1") == 0) {
+	if(ret == UCI_OK && buffer != NULL && strcmp(buffer, "1") == 0) {
 		config.shm_log = true;
 		logg("   SHM_LOG: Enabled");
 	} else {
 		logg("   SHM_LOG: Disabled");
 	}
+	FREE(buffer);
 
-	logg("Finished config file parsing");
+	// Read DEBUG_... setting from pihole-FTL.conf
+	read_debuging_settings();
 
-	if(fp != NULL)
-		fclose(fp);
+	logg("Reading uci config (/etc/config/pihole) finished");
 }
 
-static void getpath(FILE* fp, const char *option, const char *defaultloc, char **pointer)
+static void getpath(const char *option, const char *defaultloc, char **pointer)
 {
 	// This subroutine is used to read paths from pihole-FTL.conf
 	// fp:         File pointer to opened and readable config file
 	// option:     Option string ("key") to try to read
 	// defaultloc: Value used if key is not found in file
 	// pointer:    Location where read (or default) parameter is stored
-	char *buffer = parse_FTLconf(fp, option);
+	char *buffer = NULL;
+	const char *hint = "";
+	int ret = uci_get_value("pihole", option, &buffer);
+
+	if(ret == UCI_OK)
+		hint = " (user defined)";
 
 	errno = 0;
 	// Use sscanf() to obtain filename from config file parameter only if buffer != NULL
-	if(buffer == NULL || sscanf(buffer, "%127ms", pointer) != 1)
+	if(ret != UCI_OK || buffer == NULL || sscanf(buffer, "%127ms", pointer) != 1)
 	{
 		// Use standard path if no custom path was obtained from the config file
 		*pointer = strdup(defaultloc);
@@ -799,296 +791,195 @@ static void getpath(FILE* fp, const char
 	}
 	else
 	{
-		logg("   %s: Using %s", option, *pointer);
+		logg("   %s: Using %s%s", option, *pointer, hint);
 	}
+
+	FREE(buffer);
 }
 
-static char *parse_FTLconf(FILE *fp, const char *key)
+void get_privacy_level(void)
 {
-	// Return NULL if fp is an invalid file pointer
-	if(fp == NULL)
-		return NULL;
-
-	char *keystr = calloc(strlen(key)+2, sizeof(char));
-	if(keystr == NULL)
-	{
-		logg("WARN: parse_FTLconf failed: could not allocate memory for keystr");
-		return NULL;
-	}
-	sprintf(keystr, "%s=", key);
-
-	// Lock mutex
-	const int lret = pthread_mutex_lock(&lock);
-	if(config.debug & DEBUG_LOCKS)
-		logg("Obtained config lock");
-	if(lret != 0)
-		logg("Error when obtaining config lock: %s", strerror(lret));
-
-	// Go to beginning of file
-	fseek(fp, 0L, SEEK_SET);
-
-	if(config.debug & DEBUG_EXTRA)
-		logg("initial: conflinebuffer = %p, keystr = %p, size = %zu", conflinebuffer, keystr, size);
-
-	// Set size to zero if conflinebuffer is not available here
-	// This causes getline() to allocate memory for the buffer itself
-	if(conflinebuffer == NULL && size != 0)
-		size = 0;
-
-	errno = 0;
-	while(getline(&conflinebuffer, &size, fp) != -1)
-	{
-		if(config.debug & DEBUG_EXTRA)
-		{
-			logg("conflinebuffer = %p, keystr = %p, size = %zu", conflinebuffer, keystr, size);
-			logg("  while reading line \"%s\" looking for \"%s\"", conflinebuffer, keystr);
-		}
-		// Check if memory allocation failed
-		if(conflinebuffer == NULL)
-			break;
-
-		// Skip comment lines
-		if(conflinebuffer[0] == '#' || conflinebuffer[0] == ';')
-			continue;
-
-		// Skip lines with other keys
-		if((strstr(conflinebuffer, keystr)) == NULL)
-			continue;
-
-		// *** MATCH ****
-
-		// Note: value is still a pointer into the conflinebuffer,
-		// no need to duplicate memory here
-		char *value = find_equals(conflinebuffer) + 1;
-
-		// Trim whitespace at beginning and end, this function modifies
-		// the string inplace
-		trim_whitespace(value);
-
-		const int uret = pthread_mutex_unlock(&lock);
-		if(config.debug & DEBUG_LOCKS)
-			logg("Released config lock (match)");
-		if(uret != 0)
-			logg("Error when releasing config lock (match): %s", strerror(uret));
-
-		// Free keystr memory
-		free(keystr);
-		return value;
-	}
-
-	if(errno == ENOMEM)
-		logg("WARN: parse_FTLconf failed: could not allocate memory for getline");
-
-	const int uret = pthread_mutex_unlock(&lock);
-	if(config.debug & DEBUG_LOCKS)
-		logg("Released config lock (no match)");
-	if(uret != 0)
-		logg("Error when releasing config lock (no match): %s", strerror(uret));
+	// Set default value
+	config.privacylevel = PRIVACY_SHOW_ALL;
 
-	// Key not found or memory error -> return NULL
-	free(keystr);
+	int value = 0;
+	char * buffer = NULL;
+	int ret = uci_get_value("pihole", "privacylevel", &buffer);
 
-	return NULL;
-}
+	if(ret != UCI_OK && ret != UCI_ERR_NOTFOUND)
+		logg("WARNING: Something is wrong while fetching privacy level config (ret: %d).", ret);
 
-void get_privacy_level(FILE *fp)
-{
-	// See if we got a file handle, if not we have to open
-	// the config file ourselves
-	bool opened = false;
-	if(fp == NULL)
-	{
-		if((fp = fopen(FTLfiles.conf, "r")) == NULL)
-			// Return silently if there is no config file available
-			return;
-		opened = true;
-	}
+	if(ret == UCI_OK && buffer != NULL && sscanf(buffer, "%i", &value) == 1) {
+		if(value >= PRIVACY_SHOW_ALL && value <= PRIVACY_MAXIMUM) {
+			if(value > config.privacylevel)
+				logg("Notice: Increasing privacy level from %i to %i", config.privacylevel, value);
+			else if(value < config.privacylevel)
+				logg("Notice: Decreasing privacy level from %i to %i", config.privacylevel, value);
 
-	int value = 0;
-	char *buffer = parse_FTLconf(fp, "PRIVACYLEVEL");
-	if(buffer != NULL && sscanf(buffer, "%i", &value) == 1)
-	{
-		// Check for change and validity of privacy level (set in FTL.h)
-		if(value >= PRIVACY_SHOW_ALL &&
-		   value <= PRIVACY_MAXIMUM &&
-		   value > config.privacylevel)
-		{
-			logg("Notice: Increasing privacy level from %i to %i", config.privacylevel, value);
 			config.privacylevel = value;
 		}
 	}
 
-	// Have to close the config file if we opened it
-	if(opened)
-		fclose(fp);
+	FREE(buffer);
 }
 
-void get_blocking_mode(FILE *fp)
+void get_blocking_mode(void)
 {
 	// Set default value
 	config.blockingmode = MODE_NULL;
 
-	// See if we got a file handle, if not we have to open
-	// the config file ourselves
-	bool opened = false;
-	if(fp == NULL)
-	{
-		if((fp = fopen(FTLfiles.conf, "r")) == NULL)
-			// Return silently if there is no config file available
-			return;
-		opened = true;
-	}
-
 	// Get config string (if present)
-	char *buffer = parse_FTLconf(fp, "BLOCKINGMODE");
-	if(buffer != NULL)
+	char *buffer = NULL;
+	int ret = uci_get_value("pihole", "blockingmode", &buffer);
+
+	if(ret != UCI_OK && ret != UCI_ERR_NOTFOUND)
+		logg("WARNING: Something is wrong while fetching blockingmode config (ret: %d).", ret);
+
+	if(ret == UCI_OK && buffer != NULL)
 	{
-		if(strcasecmp(buffer, "NXDOMAIN") == 0)
+		if(strcasecmp(buffer, "nxdomain") == 0)
 			config.blockingmode = MODE_NX;
-		else if(strcasecmp(buffer, "NULL") == 0)
+		else if(strcasecmp(buffer, "null") == 0)
 			config.blockingmode = MODE_NULL;
-		else if(strcasecmp(buffer, "IP-NODATA-AAAA") == 0)
+		else if(strcasecmp(buffer, "ip-nodata-aaaa") == 0)
 			config.blockingmode = MODE_IP_NODATA_AAAA;
-		else if(strcasecmp(buffer, "IP") == 0)
+		else if(strcasecmp(buffer, "ip") == 0)
 			config.blockingmode = MODE_IP;
-		else if(strcasecmp(buffer, "NODATA") == 0)
+		else if(strcasecmp(buffer, "nodata") == 0)
 			config.blockingmode = MODE_NODATA;
 		else
 			logg("Ignoring unknown blocking mode, fallback is NULL blocking");
 	}
 
-	// Have to close the config file if we opened it
-	if(opened)
-		fclose(fp);
+	FREE(buffer);
 }
 
 // Routine for setting the debug flags in the config struct
-static void setDebugOption(FILE* fp, const char* option, enum debug_flags bitmask)
+static void setDebugOption(const char* option, enum debug_flags bitmask)
 {
-	const char* buffer = parse_FTLconf(fp, option);
+	char* buffer = NULL;
+	int ret = uci_get_value("debug", option, &buffer);
+
+	if(ret != UCI_OK && ret != UCI_ERR_NOTFOUND) {
+		logg("WARNING: Something is wrong while fetching %s config (ret: %d).", option, ret);
+		goto free;
+	}
 
 	// Return early if the key has not been found in FTL's config file
 	if(buffer == NULL)
 		return;
 
 	// Set bit if value equals "true", clear bit otherwise
-	if(read_bool(buffer, false))
+	if(strcmp(buffer, "1") == 0) {
 		config.debug |= bitmask;
-	else
+	} else {
 		config.debug &= ~bitmask;
+	}
+
+free:
+	FREE(buffer);
 }
 
-void read_debuging_settings(FILE *fp)
+void read_debuging_settings(void)
 {
 	// Set default (no debug instructions set)
 	config.debug = 0;
 
-	// See if we got a file handle, if not we have to open
-	// the config file ourselves
-	bool opened = false;
-	if(fp == NULL)
-	{
-		if((fp = fopen(FTLfiles.conf, "r")) == NULL)
-			// Return silently if there is no config file available
-			return;
-		opened = true;
-	}
-
 	// DEBUG_ALL
 	// defaults to: false
 	// ~0 is a shortcut for "all bits set"
-	setDebugOption(fp, "DEBUG_ALL", ~(int16_t)0);
+	setDebugOption("debug_all", ~(int16_t)0);
 
 	// DEBUG_DATABASE
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_DATABASE", DEBUG_DATABASE);
+	setDebugOption("debug_database", DEBUG_DATABASE);
 
 	// DEBUG_NETWORKING
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_NETWORKING", DEBUG_NETWORKING);
+	setDebugOption("debug_networking", DEBUG_NETWORKING);
 
 	// DEBUG_LOCKS
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_LOCKS", DEBUG_LOCKS);
+	setDebugOption("debug_locks", DEBUG_LOCKS);
 
 	// DEBUG_QUERIES
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_QUERIES", DEBUG_QUERIES);
+	setDebugOption("debug_queries", DEBUG_QUERIES);
 
 	// DEBUG_FLAGS
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_FLAGS", DEBUG_FLAGS);
+	setDebugOption("debug_flags", DEBUG_FLAGS);
 
 	// DEBUG_SHMEM
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_SHMEM", DEBUG_SHMEM);
+	setDebugOption("debug_shmem", DEBUG_SHMEM);
 
 	// DEBUG_GC
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_GC", DEBUG_GC);
+	setDebugOption("debug_gc", DEBUG_GC);
 
 	// DEBUG_ARP
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_ARP", DEBUG_ARP);
+	setDebugOption("debug_arp", DEBUG_ARP);
 
 	// DEBUG_REGEX or REGEX_DEBUGMODE (legacy config option)
 	// defaults to: false
-	setDebugOption(fp, "REGEX_DEBUGMODE", DEBUG_REGEX);
-	setDebugOption(fp, "DEBUG_REGEX", DEBUG_REGEX);
+	setDebugOption("regex_debugmode", DEBUG_REGEX);
+	setDebugOption("debug_regex", DEBUG_REGEX);
 
 	// DEBUG_API
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_API", DEBUG_API);
+	setDebugOption("debug_api", DEBUG_API);
 
 	// DEBUG_OVERTIME
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_OVERTIME", DEBUG_OVERTIME);
+	setDebugOption("debug_overtime", DEBUG_OVERTIME);
 
 	// DEBUG_EXTBLOCKED (deprecated, now included in DEBUG_QUERIES)
 
 	// DEBUG_STATUS
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_STATUS", DEBUG_STATUS);
+	setDebugOption("debug_status", DEBUG_STATUS);
 
 	// DEBUG_CAPS
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_CAPS", DEBUG_CAPS);
+	setDebugOption("debug_caps", DEBUG_CAPS);
 
 	// DEBUG_DNSSEC
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_DNSSEC", DEBUG_DNSSEC);
+	setDebugOption("debug_dnssec", DEBUG_DNSSEC);
 
 	// DEBUG_VECTORS
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_VECTORS", DEBUG_VECTORS);
+	setDebugOption("debug_vectors", DEBUG_VECTORS);
 
 	// DEBUG_RESOLVER
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_RESOLVER", DEBUG_RESOLVER);
+	setDebugOption("debug_resolver", DEBUG_RESOLVER);
 
 	// DEBUG_EDNS0
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_EDNS0", DEBUG_EDNS0);
+	setDebugOption("debug_edns0", DEBUG_EDNS0);
 
 	// DEBUG_CLIENTS
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_CLIENTS", DEBUG_CLIENTS);
+	setDebugOption("debug_clients", DEBUG_CLIENTS);
 
 	// DEBUG_ALIASCLIENTS
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_ALIASCLIENTS", DEBUG_ALIASCLIENTS);
+	setDebugOption("debug_aliasclients", DEBUG_ALIASCLIENTS);
 
 	// DEBUG_EVENTS
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_EVENTS", DEBUG_EVENTS);
+	setDebugOption("debug_events", DEBUG_EVENTS);
 
 	// DEBUG_HELPER
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_HELPER", DEBUG_HELPER);
+	setDebugOption("debug_helper", DEBUG_HELPER);
 
 	// DEBUG_EXTRA
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_EXTRA", DEBUG_EXTRA);
+	setDebugOption("debug_extra", DEBUG_EXTRA);
 
 	if(config.debug)
 	{
@@ -1120,24 +1011,4 @@ void read_debuging_settings(FILE *fp)
 		// Enable debug logging in dnsmasq (only effective before starting the resolver)
 		argv_dnsmasq[2] = "--log-debug";
 	}
-
-	// Have to close the config file if we opened it
-	if(opened)
-		fclose(fp);
-}
-
-static bool read_bool(const char *option, const bool fallback)
-{
-	if(option == NULL)
-		return fallback;
-
-	else if(strcasecmp(option, "false") == 0 ||
-	        strcasecmp(option, "no") == 0)
-		return false;
-
-	else if(strcasecmp(option, "true") == 0 ||
-	        strcasecmp(option, "yes") == 0)
-		return true;
-
-	return fallback;
 }
--- a/src/config.h
+++ b/src/config.h
@@ -21,13 +21,15 @@
 #include "static_assert.h"
 // struct in_addr, in6_addr
 #include <netinet/in.h>
+// config uci
+#include "config_uci.h"
 
-void init_config_mutex(void);
 void getLogFilePath(void);
 void read_FTLconf(void);
-void get_privacy_level(FILE *fp);
-void get_blocking_mode(FILE *fp);
-void read_debuging_settings(FILE *fp);
+void get_privacy_level(void);
+void get_blocking_mode(void);
+void read_debuging_settings(void);
+void check_blocking_status(void);
 
 // We do not use bitfields in here as this struct exists only once in memory.
 // Accessing bitfields may produce slightly more inefficient code on some
@@ -94,8 +96,6 @@ typedef struct {
 ASSERT_SIZEOF(ConfigStruct, 112, 104, 104);
 
 typedef struct {
-	const char* conf;
-	const char* snapConf;
 	char* log;
 	char* pid;
 	char* port;
@@ -103,7 +103,6 @@ typedef struct {
 	char* FTL_db;
 	char* gravity_db;
 	char* macvendor_db;
-	char* setupVars;
 	char* auditlist;
 } FTLFileNamesStruct;
 
--- /dev/null
+++ b/src/config_uci.c
@@ -0,0 +1,143 @@
+#include "FTL.h"
+#include "log.h"
+#include "config_uci.h"
+
+static struct uci_context *uci_ctx = NULL;
+static struct uci_package *uci_pkg = NULL;
+
+static struct uci_package *uci_init_package(void)
+{
+	struct uci_context *ctx = uci_ctx;
+	struct uci_package *pkg = NULL;
+
+	if (!ctx) {
+		ctx = uci_alloc_context();
+		uci_ctx = ctx;
+		ctx->flags &= ~UCI_FLAG_STRICT;
+	} else {
+		pkg = uci_lookup_package(ctx, "pihole");
+		if (pkg)
+			uci_unload(ctx, pkg);
+	}
+
+	if (uci_load(ctx, "pihole", &pkg))
+		return NULL;
+
+	return pkg;
+}
+
+void _uci_reload(const char *func, const char *file, const int line)
+{
+    struct uci_context *ctx = uci_ctx;
+
+    if (!ctx) {
+        ctx = uci_alloc_context();
+        uci_ctx = ctx;
+        ctx->flags &= ~UCI_FLAG_STRICT;
+		logg("Re-Allocating UCI Context (Should not be happened), called from: %s - %s:%d", func, file, line); 
+    }
+
+    uci_pkg = uci_lookup_package(ctx, "pihole");
+    uci_unload(uci_ctx, uci_pkg);
+    uci_load(uci_ctx, "pihole", &uci_pkg);
+
+	logg("Reloading UCI Config, called from: %s - %s:%d", func, file, line); 
+}
+
+int uci_init(void) {
+	uci_pkg = uci_init_package();
+	if (!uci_pkg) {
+		char *errstr;
+		uci_get_errorstr(uci_ctx, &errstr, NULL);
+		syslog(LOG_ERR, "pihole-FTL: Failed to load pihole config (%s)", errstr);
+		free(errstr);
+		return -1;
+	}
+
+	return 0;
+}
+
+void uci_clean(void)
+{
+	if (uci_pkg != NULL) {
+		logg("Unloading uci package config");
+		uci_unload(uci_ctx, uci_pkg);
+		uci_pkg = NULL;
+	}
+	if (uci_ctx != NULL) {
+		logg("Cleaning uci context");
+		uci_free_context(uci_ctx);
+		uci_ctx = NULL;
+	}
+}
+
+static char * __attribute__ ((malloc)) uci_get_list_value(struct uci_list *list)
+{
+	if (!list)
+		return NULL;
+
+//	if (uci_list_empty(list))
+//		return NULL;
+
+	struct uci_element *e = NULL;
+	char buffer[512] = { 0 };
+	unsigned pos = 0;
+
+	buffer[0] = 0;
+	uci_foreach_element(list, e) {
+		if (e->name)
+			pos += snprintf(&buffer[pos], sizeof(buffer) - pos, "%s%s", e->name, ",");
+	}
+
+	if (pos)
+		buffer[pos - 1] = 0;
+
+	return strdup(buffer);
+}
+
+static struct uci_section * __attribute__((pure)) get_uci_section_type(struct uci_package *pkg, const char *s)
+{
+	struct uci_element *e;
+	uci_foreach_element(&pkg->sections, e) {
+		struct uci_section *section = uci_to_section(e);
+		if (strcmp(section->type, s) == 0)
+			return section;
+	}
+
+	return NULL;
+}
+
+int uci_get_value(const char *section, const char *option, char **val)
+{
+	int err = UCI_OK;
+
+	if(!uci_ctx) {
+		err = UCI_ERR_MEM;
+		goto ret;
+	}
+
+	struct uci_section *sec = get_uci_section_type(uci_pkg, section);
+	if(!sec || !option) {
+		err = UCI_ERR_NOTFOUND;
+		goto ret;
+	}
+
+	struct uci_element *e;
+	uci_foreach_element(&sec->options, e) {
+		struct uci_option* opt = uci_to_option(e);
+		if(strcmp(opt->e.name, option) == 0) {
+			if(opt->type == UCI_TYPE_STRING)
+				*val = opt->v.string ? strdup(opt->v.string) : NULL;
+			else if (opt->type == UCI_TYPE_LIST)
+				*val = uci_get_list_value(&opt->v.list);
+
+			return UCI_OK;
+		} else {
+			err = UCI_ERR_NOTFOUND;
+		}
+	}
+
+ret:
+	*val = NULL;
+	return err;
+}
--- /dev/null
+++ b/src/config_uci.h
@@ -0,0 +1,17 @@
+#ifndef CONFIG_UCI_H
+#define CONFIG_UCI_H
+
+#include <uci.h>
+
+#ifndef FREE
+#define FREE(target) do { if(target) { free(target); target = NULL; } } while (0)
+#endif
+
+#define uci_reload() _uci_reload(__FUNCTION__, __FILE__, __LINE__)
+
+void uci_clean(void);
+int uci_init(void);
+void _uci_reload(const char *func, const char *file, const int line);
+int uci_get_value(const char *section, const char *option, char **val);
+
+#endif
--- a/src/daemon.c
+++ b/src/daemon.c
@@ -238,6 +238,9 @@ static void terminate_threads(void)
 // Clean up on exit
 void cleanup(const int ret)
 {
+	// free uci
+	uci_clean();
+
 	// Do proper cleanup only if FTL started successfully
 	if(resolver_ready)
 	{
--- a/src/database/database-thread.c
+++ b/src/database/database-thread.c
@@ -112,7 +112,7 @@ void *DB_thread(void *val)
 
 		// Reload privacy level from pihole-FTL.conf
 		if(get_and_clear_event(RELOAD_PRIVACY_LEVEL))
-			get_privacy_level(NULL);
+			get_privacy_level();
 
 		BREAK_IF_KILLED();
 
--- a/src/dnsmasq/config.h
+++ b/src/dnsmasq/config.h
@@ -218,7 +218,7 @@ RESOLVFILE
 #   if defined(__FreeBSD__)
 #      define CONFFILE "/usr/local/etc/dnsmasq.conf"
 #   else
-#      define CONFFILE "/etc/dnsmasq.conf"
+#      define CONFFILE "/tmp/etc/dnsmasq.conf"
 #   endif
 #endif
 
--- a/src/dnsmasq_interface.c
+++ b/src/dnsmasq_interface.c
@@ -1768,6 +1768,9 @@ static void FTL_forwarded(const unsigned
 
 void FTL_dnsmasq_reload(void)
 {
+	// reload config
+	uci_reload();
+
 	// This function is called by the dnsmasq code on receive of SIGHUP
 	// *before* clearing the cache and rereading the lists
 	logg("Reloading DNS cache");
@@ -1782,10 +1785,10 @@ void FTL_dnsmasq_reload(void)
 	// cache and reread all blocking lists
 	// Passing NULL to this function means it has to open the config file on
 	// its own behalf (on initial reading, the config file is already opened)
-	get_blocking_mode(NULL);
+	get_blocking_mode();
 
 	// Reread pihole-FTL.conf to see which debugging flags are set
-	read_debuging_settings(NULL);
+	read_debuging_settings();
 
 	// Gravity database updates
 	// - (Re-)open gravity database connection
--- a/src/main.c
+++ b/src/main.c
@@ -48,8 +48,10 @@ int main (int argc, char* argv[])
 	// to have arg{c,v}_dnsmasq initialized
 	parse_args(argc, argv);
 
+	// init uci
+	uci_init();
+
 	// Try to open FTL log
-	init_config_mutex();
 	init_FTL_log();
 	timer_start(EXIT_TIMER);
 	logg("########## FTL started on %s! ##########", hostname());
@@ -96,7 +98,6 @@ int main (int argc, char* argv[])
 		DB_read_queries();
 
 	log_counter_info();
-	check_setupVarsconf();
 
 	// Check for availability of capabilities in debug mode
 	if(config.debug & DEBUG_CAPS)
--- a/src/setupVars.c
+++ b/src/setupVars.c
@@ -16,118 +16,6 @@
 int setupVarsElements = 0;
 char ** setupVarsArray = NULL;
 
-void check_setupVarsconf(void)
-{
-	FILE *setupVarsfp;
-	if((setupVarsfp = fopen(FTLfiles.setupVars, "r")) == NULL)
-	{
-		logg("WARN: Opening of setupVars.conf failed!");
-		logg("      Make sure it exists and is readable");
-		logg("      Message: %s", strerror(errno));
-	}
-	else
-	{
-		logg("Successfully accessed setupVars.conf");
-		fclose(setupVarsfp);
-	}
-}
-
-char* __attribute__((pure)) find_equals(const char* s)
-{
-	const char* chars = "=";
-	while (*s && (!chars || !strchr(chars, *s)))
-		s++;
-	return (char*)s;
-}
-
-void trim_whitespace(char *string)
-{
-	// isspace(char*) man page:
-	// checks for white-space  characters. In the "C" and "POSIX"
-	// locales, these are: space, form-feed ('\f'), newline ('\n'),
-	// carriage return ('\r'), horizontal tab ('\t'), and vertical tab
-	// ('\v').
-	char *original = string, *modified = string;
-	// Trim any whitespace characters (see above) at the beginning by increasing the pointer address
-	while (isspace((unsigned char)*original))
-		original++;
-	// Copy the content of original into modified as long as there is something in original
-	while ((*modified = *original++) != '\0')
-		modified++;
-	// Trim any whitespace characters (see above) at the end of the string by overwriting it
-	// with the zero character (marking the end of a C string)
-	while (modified > string && isspace((unsigned char)*--modified))
-		*modified = '\0';
-}
-
-// This will hold the read string
-// in memory and will serve the space
-// we will point to in the rest of the
-// process (e.g. setupVarsArray will
-// actually point to memory addresses
-// which we allocate for this buffer.
-char * linebuffer = NULL;
-size_t linebuffersize = 0;
-
-char * read_setupVarsconf(const char * key)
-{
-	FILE *setupVarsfp;
-	if((setupVarsfp = fopen(FTLfiles.setupVars, "r")) == NULL)
-	{
-		logg("WARN: Reading setupVars.conf failed: %s", strerror(errno));
-		return NULL;
-	}
-
-	// Allocate keystr
-	char * keystr = calloc(strlen(key)+2, sizeof(char));
-	if(keystr == NULL)
-	{
-		logg("WARN: read_setupVarsconf failed: could not allocate memory for keystr");
-		fclose(setupVarsfp);
-		return NULL;
-	}
-	sprintf(keystr, "%s=", key);
-
-	errno = 0;
-	while(getline(&linebuffer, &linebuffersize, setupVarsfp) != -1)
-	{
-		// Strip (possible) newline
-		linebuffer[strcspn(linebuffer, "\n")] = '\0';
-
-		// Skip comment lines
-		if(linebuffer[0] == '#' || linebuffer[0] == ';')
-			continue;
-
-		// Skip lines with other keys
-		if((strstr(linebuffer, keystr)) == NULL)
-			continue;
-
-		// otherwise: key found
-		fclose(setupVarsfp);
-		free(keystr);
-		return (find_equals(linebuffer) + 1);
-	}
-
-	if(errno == ENOMEM)
-		logg("WARN: read_setupVarsconf failed: could not allocate memory for getline");
-
-	// Key not found -> return NULL
-	fclose(setupVarsfp);
-
-	// Freeing keystr, not setting to NULL, since not used outside of this routine
-	free(keystr);
-
-	// Freeing and setting to NULL to prevent a dangling pointer
-	if(linebuffer != NULL)
-	{
-		free(linebuffer);
-		linebuffersize = 0;
-		linebuffer = NULL;
-	}
-
-	return NULL;
-}
-
 // split string in form:
 //   abc,def,ghi
 // into char ** array:
@@ -165,25 +53,8 @@ void clearSetupVarsArray(void)
 		free(setupVarsArray);
 		setupVarsArray = NULL;
 	}
-	if(linebuffer != NULL)
-	{
-		free(linebuffer);
-		linebuffersize = 0;
-		linebuffer = NULL;
-	}
 }
 
-/* Example
-	char * iface = read_setupVarsconf("API_EXCLUDE_DOMAINS");
-	if(iface != NULL)
-		logg_str("Interface: ",iface);
-	getSetupVarsArray(iface);
-	int i;
-	for (i = 0; i <= setupVarsElements; ++i)
-		printf ("[%d] = %s\n", i, setupVarsArray[i]);
-	clearSetupVarsArray();
-*/
-
 bool insetupVarsArray(const char * str)
 {
 	// Check for possible NULL pointer
@@ -222,36 +93,27 @@ bool insetupVarsArray(const char * str)
 	return false;
 }
 
-bool __attribute__((pure)) getSetupVarsBool(const char * input)
-{
-	if((strcmp(input, "true")) == 0)
-		return true;
-	else
-		return false;
-}
-
 // Global variable showing current blocking status
 enum blocking_status blockingstatus = BLOCKING_UNKNOWN;
 
 void check_blocking_status(void)
 {
-	const char* blocking = read_setupVarsconf("BLOCKING_ENABLED");
+	char* blocking = NULL;
 	const char* message;
+	uci_get_value("pihole", "blocking_enabled", &blocking);
 
-	if(blocking == NULL || getSetupVarsBool(blocking))
+	if(blocking == NULL || strcmp(blocking, "1") == 0)
 	{
-		// Parameter either not present in setupVars.conf
-		// or explicitly set to true
 		blockingstatus = BLOCKING_ENABLED;
 		message = "enabled";
 		clearSetupVarsArray();
 	}
 	else
 	{
-		// Disabled
 		blockingstatus = BLOCKING_DISABLED;
 		message = "disabled";
 	}
 
 	logg("Blocking status is %s", message);
+	FREE(blocking);
 }
--- a/src/setupVars.h
+++ b/src/setupVars.h
@@ -10,15 +10,9 @@
 #ifndef SETUPVARS_H
 #define SETUPVARS_H
 
-void check_setupVarsconf(void);
-char * read_setupVarsconf(const char * key);
 void getSetupVarsArray(const char * input);
 void clearSetupVarsArray(void);
 bool insetupVarsArray(const char * str);
-bool getSetupVarsBool(const char * input) __attribute__((pure));
-char* find_equals(const char* s) __attribute__((pure));
-void trim_whitespace(char *string);
-void check_blocking_status(void);
 
 extern unsigned char blockingstatus;
 
--- a/src/signals.c
+++ b/src/signals.c
@@ -191,6 +191,9 @@ static void SIGRT_handler(int signum, si
 
 	if(rtsig == 0)
 	{
+		// reload config
+		uci_reload();
+
 		// Reload
 		// - gravity
 		// - exact whitelist
--- a/tools/socket_client.c
+++ b/tools/socket_client.c
@@ -40,7 +40,7 @@ int main (int argc, char **argv) {
 	address.sun_family = AF_LOCAL;
 
 	char *command = ">stats";
-	strcpy(address.sun_path,"/run/pihole/FTL.sock");
+	strcpy(address.sun_path,"/var/run/pihole/FTL.sock");
 
 	int i;
 	for(i = 1; i < argc; i++) {
